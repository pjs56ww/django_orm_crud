# Django ORM
### 1. 모델 디자인(작성)하기

```python

# 장고가 기본적으로 제공하는 모델s가 가지고 있는 모델이라는 함수?를 가져온다.? 
# 게시판을 만들겁니다.
class Article(models.Model):
    # id(pk)는 기본적으로 처음 테이블이 생성될 때 자동으로 만들어 진다.
    # id = models.AutoField(primary_key=True)

    # CharField 에서는 max_length가 필수 인자다.
    title = models.CharField(max_length=20) # 클래스 변수(DB의 필드)
    content = models.TextField() # 클래스 변수(DB의 필드)
    created_at = models.DateTimeField(auto_now_add=True)  # 자동으로 지금 추가되었을 때 생성
    
```

- models.___()에 대한 정보: https://docs.djangoproject.com/en/2.2/ref/models/fields/#module-django.db.models.fields



### 2. 장고에게 알려주기(migrations)

```bash
$ python manage.py makemigrations

```

내가 모델을 짰다는 것을 장고에게 신고한다.

django한테 model 작성했음을 알림.



/<project>/<app>/migrarions/0001_initial.py가 생성된다.

```python
# Generated by Django 2.2.4 on 2019-08-21 07:52

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Article',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=20)),
                ('content', models.TextField()),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]

```

- 0001_initial.py 의 내용을 확인해본다. 만족한다면 3.으로 넘어간다.



### 3. 데이터베이스 반영시키기

```bash
$ python manage.py migrate
```

4. SQLite Extention 저장

cntl + shift + p -> SQLite: Open Database -> db.sqlite3

SQLITE EXPLORER -> db.sqlite3 -> articles_article TABLE 열면 확인 가능합니다.



### 4. 데이터 베이스 쓰기(write, save)

1) django project 환경에 접근하기 위해 django manage.py 를 이용하여 python shell 을 연다.

현재창이 프로젝트의 디렉토리에서 시작해야 한다.

```bash
student@M702 MINGW64 ~/development/django/django_orm_crud (master)
$ python manage.py shell
```



2)우리가 만든 Article 이라는 class를 import 해야 사용가능

```python
from articles.models import Article
```



3) 확인해보기

```shell
 Article.objects.all()
 <QuerySet []>
```

- Article : 우리가 만든 모델 
-  objects : 데이터베이스의 객체
- `<QuerySet []>` : 다수의 데이터를 가져오는 함수
- 아티클이라고 정의한 모델에서 오브젝트(객체)를 통해서 데이터 베이스에 접근하게 된다.

- 우리는  `Artcle.objects` 를 통해 모든 명령을 내릴 것이다.



4) 데이터를 저장하는 3 가지 방법

첫번째 방법

- ORM을 쓰는 이유는? : DB를 조작하는 것을 객체지향 프로그래밍(클래스)처럼 하기 위해서

  ```shell
  >>> article = Article()  # 클래스를 조작하듯이 사용하자.
  >>> article
  <Article: Article object (None)>
  
  # 사용자가 직접 입력해야 하는 atribute들을 입력한다. datetimefield는 auto이므로 입력하지 않아도 된다.
  >>> article.title = 'First article'
  >>> article.content = 'hello aaa'
  
  # 입력한 값 확인하기
  >>> article.title
  'First article'
  >>> article.content
  'hello aaa'
  
  # 저장을 하지 않은 상태에서는 Article 클래스에 object가 등록이 되어있지 않는다.
  >>> article
  <Article: Article object (None)>
  
  # 저장하기
  >>> article.save()
  
  # 확인하기 / 등록된 것을 확인할 수 있다.
  >>> article
  <Article: Article object (1)>
  
  >>> Article.objects.all()
  <QuerySet [<Article: Article object (1)>]>
  ```

  - SQLITE EXPLORER -> db.sqlite3 -> articles_article TABLE 보면 확인할 수 있다.

  

두번째 방법

- 함수에서 keyword 인자 넘기기 방식과 동일

  ```shell
  >>> article = Article(title='second article', content='second contentgkgkg')
  >>> article.save()
  >>> article
  <Article: Article object (2)>
  ```



세번째 방법

- create 를 사용하면 쿼리셋 캑체를 생성하고 저장하는 로직이 한번의 스텝인 방법

  ```shell
  >>> Article.objects.create(title='third title', content='thidddasd djangogogogo')
  <Article: Article object (3)>
  ```

  - 위의 방식은 `article.save()`를 수행하지 않아도 된다.



번외

- article(인스턴스)를 저장하기 전에 저장해도 되는지 확인하는 작업이 필요함

  ```
  # 빈스트링이 들어갈 상황
  >>> article = Article()
  >>> article.title = 'dd'
  >>> article
  <Article: Article object (None)>
  >>> article.content
  ''
  >>> article.save()
  ```

  - 파이썬 내부에서 빈 데이터도 같이 저장하도록 설정하게 되어있음.

- 검수

  ```shell
  >>> article = Article()
  >>> article.title = 'a'
  
  # 이대로 저장해도 되는지 확인해보는 함수
  >>> article.full_clean()
  
  Traceback (most recent call last):
    File "<console>", line 1, in <module>
    File "C:\Users\student\development\django\django_orm_crud\venv\lib\site-packages\django\db\models\base.py", line 1203, in full_clean
      raise ValidationError(errors)
  django.core.exceptions.ValidationError: {'content': ['이 필드는 빈 칸으로 둘 수 없습니다.']}
  ```

  

### 5. 데이터 베이스읽기(read)

#### 1) 모든객체

```shell
>>> Article.objects.all()
<QuerySet [<Article: Article object (1)>, <Article: Article object (2)>, <Article: Article object (3)>, <Article: Article object (4)>, <Article: Article object (5)>]>
```

- 각 객체안에 어떤 데이터가 들어가 있는지 확인하려면 다른 조작을 해야한다.



article 표현방식을 바꾸는 방법

<app>/models.py

```python
class Article(models.Model):
    # id(pk)는 기본적으로 처음 테이블이 생성될 때 자동으로 만들어 진다.
    # id = models.AutoField(primary_key=True)

    # 모든 filed는 기본적으로 not null 비어있으면 안된다.

    # CharField 에서는 max_length가 필수 인자다.
    title = models.CharField(max_length=20) # 클래스 변수(DB의 필드)
    content = models.TextField() # 클래스 변수(DB의 필드)
    created_at = models.DateTimeField(auto_now_add=True)  # 자동으로 지금 추가되었을 때 생성
    updated_at = models.DateTimeField(auto_now=True)  # 자동으로 시간을 찍어준다?

    def __str__(self):
        return f'{self.id}번 글 - {self.title} : {self.content}'
```

- 작성한 뒤 쉘을 한번 닫고, 다시 실행한다. 새로 저장한 함수를 적용시키기 위해서

  ```shell
  >>> exit()
  $ python manage.py shell
  >>> from articles.models import Article
  ```

  

- 모든객체 가져오기

  ```shell
  >>> Article.objects.all()
  <QuerySet [<Article: 1번 글 - First article : hello aaa>, <Article: 2번 글 - second article : second contentgkgkg>, <Article: 3번 글 - third title : thidddasd djangogogogo>,
  <Article: 4번 글 - dd : >, <Article: 5번 글 -  : >]
  ```



#### 2) title이 second title인 객체만 가져오기

```shell
>>> Article.objects.filter(title='second article')
# 쿼리셋 형태로 가져온다.
<QuerySet [<Article: 2번 글 - second article : second contentgkgkg>]>
```



- 만약 타이틀이 두 개일 때 라면?

  ```shell
  >>> Article.objects.create(title='second title', content='hello aaa')
  <Article: 6번 글 - second title : hello aaa>
  >>> Article.objects.create(title='second title', content='fffffeqwfefeo aaa')
  <Article: 7번 글 - second title : fffffeqwfefeo aaa>
  >>> Article.objects.filter(title='second title')
  <QuerySet [<Article: 6번 글 - second title : hello aaa>, <Article: 7번 글 - second title : fffffeqwfefeo aaa>]>
  
  
  ```

  

- 두개의 글 중 첫 번째 것을 가져와라.

  ```shell
  >>> querySet = Article.objects.filter(title='second title')
  >>> querySet
  <QuerySet [<Article: 6번 글 - second title : hello aaa>, <Article: 7번 글 - second title : fffffeqwfefeo aaa>]>
  >>> querySet.first()
  <Article: 6번 글 - second title : hello aaa>
  ---
  >>> Article.objects.filter(title='second title').first()
  <Article: 6번 글 - second title : hello aaa>
  ```



#### 3) db에 저장된 글 중에서 pk가 1인 글만 가지고 오기

```shell
>>> Article.objects.get(pk=1)
<Article: 1번 글 - First article : hello aaa>
```

- get()으로 가져올 수 있는 것은 오직 pk만 가능 왜? get()은 dict형식에서 key값을 받는데 이는 하나만 있는 값이므로 다른 atribute로 접근 불가.



```shell
>>> Article.objects.get(pk=111)
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  File "C:\Users\student\development\django\django_orm_crud\venv\lib\site-packages\django\db\models\manager.py", line 82, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "C:\Users\student\development\django\django_orm_crud\venv\lib\site-packages\django\db\models\query.py", line 408, in get
    self.model._meta.object_name
articles.models.Article.DoesNotExist: Article matching query does not exist.
```

- pk값이 없는 객체는 불러올 수 없다.



```shell
>>> Article.objects.get(title='second title')
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  File "C:\Users\student\development\django\django_orm_crud\venv\lib\site-packages\django\db\models\manager.py", line 82, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "C:\Users\student\development\django\django_orm_crud\venv\lib\site-packages\django\db\models\query.py", line 412, in get
    (self.model._meta.object_name, num)
articles.models.Article.MultipleObjectsReturned: get() returned more than one Article -- it returned 2!
```

- 유일하지 않은 atribute를 불러올때에도 오류가 뜬다.



- get() 과 filter() 차이점

  1) get()으로 불러오려면 반환값이 무조건 1개여야 한다.

  2) filter()로 불러오려면 반환값의 개수가 상환 없다.



#### 4) 오름차순

```shell
>>> articles = Article.objects.order_by('pk')
>>> articles
<QuerySet [<Article: 1번 글 - First article : hello aaa>, <Article: 2번 글 - second article : second contentgkgkg>, <Article: 3번 글 - third title : thidddasd djangogogogo>,
<Article: 4번 글 - dd : >, <Article: 5번 글 -  : >, <Article: 6번 글 - second title : hello aaa>, <Article: 7번 글 - second title : fffffeqwfefeo aaa>]>
```



#### 5) 내림차순

```shell
>>> articles = Article.objects.order_by('-pk')
>>> articles
<QuerySet [<Article: 7번 글 - second title : fffffeqwfefeo aaa>, <Article: 6번 글 - second title : hello aaa>, <Article: 5번 글 -  : >, <Article: 4번 글 - dd : >, <Article: 3번 글 - third title : thidddasd djangogogogo>, <Article: 2번 글 - second article : second contentgkgkg>, <Article: 1번 글 - First article : hello aaa>]>
```



#### 6) 인덱스 접근

```shell
>>> article = articles[2]
>>> article
<Article: 5번 글 -  : >
```

- querySet은 리스트는 아니지만 리스트처럼 접근이 가능



#### 7) LIKE - 문자열을 포함하고 있는 값을 가지고 오는 방법.

장고 orm은 이름(title)과 필터(filter)를 더블 언더스코어로 구분합니다.

```shell
>>> articles = Article.objects.filter(title__contains='sec')
>>> articles
<QuerySet [<Article: 2번 글 - second article : second contentgkgkg>, <Article: 6번 글 - second title : hello aaa>, <Article: 7번 글 - second title : fffffeqwfefeo aaa>]>
```



#### 8) startswith

```shell
>>> articles = Article.objects.filter(title__startswith='first')
>>> articles
<QuerySet [<Article: 1번 글 - First article : hello aaa>]>
```



#### 9) endswith

```shell
>>> articles = Article.objects.filter(title__endswith='title')
>>> articles
<QuerySet [<Article: 3번 글 - third title : thidddasd djangogogogo>, <Article: 6번 글 - second title : hello aaa>, <Article: 7번 글 - second title : fffffeqwfefeo aaa>]>
```



### 6. 데이터베이스 자료 삭제(delete)

```shell
>>> article = Article.objects.get(pk=1)
>>> article.delete()
(1, {'articles.Article': 1})
```



### 7. 데이터베이스 바꾸기(update)

- 기존 데이터

| #    | id   | title          | content                | created_at                 | updated_at                 |
| ---- | ---- | -------------- | ---------------------- | -------------------------- | -------------------------- |
| 1    | 2    | second article | second contentgkgkg    | 2019-08-22 01:47:52.408184 | 2019-08-22 01:47:52.408184 |
| 2    | 3    | third title    | thidddasd djangogogogo | 2019-08-22 01:50:41.965381 | 2019-08-22 01:50:41.965381 |
| 3    | 4    | dd             |                        | 2019-08-22 02:06:46.456211 | 2019-08-22 02:06:46.456211 |
| 4    | 6    | second title   | hello aaa              | 2019-08-22 02:21:48.490151 | 2019-08-22 02:21:48.490151 |
| 5    | 7    | second title   | fffffeqwfefeo aaa      | 2019-08-22 02:23:35.604831 | 2019-08-22 02:23:35.604831 |



article 인스턴스 호출 후 값 변경하여 `.save()`함수 실행

```shell
>>> article = Article.objects.get(pk=4)
>>> article.content
''
>>> article.content = 'new content'
>>> article.save()
```



update 후 상태

| #    | id   | title          | content                | created_at                 | updated_at                 |
| ---- | ---- | -------------- | ---------------------- | -------------------------- | -------------------------- |
| 1    | 2    | second article | second contentgkgkg    | 2019-08-22 01:47:52.408184 | 2019-08-22 01:47:52.408184 |
| 2    | 3    | third title    | thidddasd djangogogogo | 2019-08-22 01:50:41.965381 | 2019-08-22 01:50:41.965381 |
| 3    | 4    | dd             | new content            | 2019-08-22 02:06:46.456211 | 2019-08-22 03:06:46.597752 |
| 4    | 6    | second title   | hello aaa              | 2019-08-22 02:21:48.490151 | 2019-08-22 02:21:48.490151 |
| 5    | 7    | second title   | fffffeqwfefeo aaa      | 2019-08-22 02:23:35.604831 | 2019-08-22 02:23:35.604831 |

- created_at 과 updated_at의 데이터가 다르다.



### 8. Django 관리자 권한 

당고 관리자 권한 페이지를 사용하기 위해 등록한다.

/articles/admin.py

```python
from .models import Article

admin.site.register(Article) # 우리가 작성한 Article이라는 모델(클래스)를 admin page에 등록하겠다.

# 등록하기 위해 admin페이지에 접속한다.
$ python manage.py runserver
```

![캡처](images/캡처.PNG)

admin 계정은 현재 없다. 계정을 생성한다.

```python
$ python manage.py createsuperuser


사용자 이름 (leave blank to use 'student'): sinho
이메일 주소: dltlsgh5@naver.com
Password:
Password (again):
Superuser created successfully.
```

- 비밀번호 : tlsgh123

![캡처1](images/캡처1.PNG)

- 확인

결과1

![캡처2](images/캡처2.PNG)

![캡처3](images/캡처3.PNG)

![캡처4](images/캡처4.PNG)

### 9. 관리자 화면 관리

artricles/admin.py

```python
from django.contrib import admin
from .models import Article

@admin.register(Article)
class ArticleAdmin(admin.ModelAdmin):
    list_display = ('id', 'title', 'content', 'created_at', 'updated_at',)

```

- 관리자 디스플레이를 내가 원하는 정보를 배치할 수 있다.

결과화면



![캡처5](images/캡처5.PNG)

tip : 초보몽키 블로그





### 10. django-extensions 설치

```python
$ pip install django-extensions
```



<project>/settings.py

extensions 등록

```python
INSTALLED_APPS = [
    'articles',

    # third party
    'django_extensions',
    
    ]
```



!!!! **install할때는 django-extensions, 등록할때는 django_extensions**

shell_plus 적용

```bash
$ python manage.py shell_plus
```

